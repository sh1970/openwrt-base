--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -1015,6 +1015,54 @@ mt7530_port_disable(struct dsa_switch *d
 	mutex_unlock(&priv->reg_mutex);
 }
 
+static int
+mt7530_port_change_mtu(struct dsa_switch *ds, int port, int new_mtu)
+{
+       struct mt7530_priv *priv = ds->priv;
+       struct mii_bus *bus = priv->bus;
+       int length;
+       u32 val;
+
+       /* When a new MTU is set, DSA always set the CPU port's MTU to the
+        * largest MTU of the slave ports. Because the switch only has a global
+        * RX length register, only allowing CPU port here is enough.
+        */
+       if (!dsa_is_cpu_port(ds, port))
+               return 0;
+
+       mutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);
+
+       val = mt7530_mii_read(priv, MT7530_GMACCR);
+       val &= ~MAX_RX_PKT_LEN_MASK;
+
+       /* RX length also includes Ethernet header, MTK tag, and FCS length */
+       length = new_mtu + ETH_HLEN + MTK_HDR_LEN + ETH_FCS_LEN;
+       if (length <= 1522) {
+               val |= MAX_RX_PKT_LEN_1522;
+       } else if (length <= 1536) {
+               val |= MAX_RX_PKT_LEN_1536;
+       } else if (length <= 1552) {
+               val |= MAX_RX_PKT_LEN_1552;
+       } else {
+               val &= ~MAX_RX_JUMBO_MASK;
+               val |= MAX_RX_JUMBO(DIV_ROUND_UP(length, 1024));
+               val |= MAX_RX_PKT_LEN_JUMBO;
+       }
+
+       mt7530_mii_write(priv, MT7530_GMACCR, val);
+
+       mutex_unlock(&bus->mdio_lock);
+
+       return 0;
+}
+
+static int
+mt7530_port_max_mtu(struct dsa_switch *ds, int port)
+{
+       return MT7530_MAX_MTU;
+}
+
+
 static void
 mt7530_stp_state_set(struct dsa_switch *ds, int port, u8 state)
 {
@@ -1656,6 +1704,7 @@ mt7530_setup(struct dsa_switch *ds)
 	 */
 	dn = dsa_to_port(ds, MT7530_CPU_PORT)->master->dev.of_node->parent;
 	ds->configure_vlan_while_not_filtering = true;
+	ds->mtu_enforcement_ingress = true;
 
 	if (priv->id == ID_MT7530) {
 		regulator_set_voltage(priv->core_pwr, 1000000, 1000000);
@@ -1911,6 +1960,7 @@ mt7531_setup(struct dsa_switch *ds)
 	}
 
 	ds->configure_vlan_while_not_filtering = true;
+	ds->mtu_enforcement_ingress = true;
 
 	/* Flush the FDB table */
 	ret = mt7530_fdb_cmd(priv, MT7530_FDB_FLUSH, NULL);
@@ -2650,6 +2700,8 @@ static const struct dsa_switch_ops mt753
 	.get_sset_count		= mt7530_get_sset_count,
 	.port_enable		= mt7530_port_enable,
 	.port_disable		= mt7530_port_disable,
+	.port_change_mtu        = mt7530_port_change_mtu,
+	.port_max_mtu           = mt7530_port_max_mtu,
 	.port_stp_state_set	= mt7530_stp_state_set,
 	.port_bridge_join	= mt7530_port_bridge_join,
 	.port_bridge_leave	= mt7530_port_bridge_leave,
--- a/drivers/net/dsa/mt7530.h
+++ b/drivers/net/dsa/mt7530.h
@@ -11,6 +11,9 @@
 #define MT7530_NUM_FDB_RECORDS		2048
 #define MT7530_ALL_MEMBERS		0xff
 
+#define MTK_HDR_LEN    4
+#define MT7530_MAX_MTU (15 * 1024 - ETH_HLEN - ETH_FCS_LEN - MTK_HDR_LEN)
+
 enum mt753x_id {
 	ID_MT7530 = 0,
 	ID_MT7621 = 1,
@@ -299,7 +302,16 @@ enum mt7530_vlan_port_attr {
 
 /* Register for port debug count */
 #define MT7531_DBG_CNT(x)		(0x3018 + (x) * 0x100)
-#define  MT7531_DIS_CLR			BIT(31)
+#define MT7531_DIS_CLR			BIT(31)
+
+#define MT7530_GMACCR			0x30e0
+#define MAX_RX_JUMBO(x)			((x) << 2)
+#define MAX_RX_JUMBO_MASK		GENMASK(5, 2)
+#define MAX_RX_PKT_LEN_MASK		GENMASK(1, 0)
+#define MAX_RX_PKT_LEN_1522		0x0
+#define MAX_RX_PKT_LEN_1536		0x1
+#define MAX_RX_PKT_LEN_1552		0x2
+#define MAX_RX_PKT_LEN_JUMBO		0x3
 
 /* Register for MIB */
 #define MT7530_PORT_MIB_COUNTER(x)	(0x4000 + (x) * 0x100)
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -355,7 +355,7 @@ static void mtk_mac_config(struct phylin
 	/* Setup gmac */
 	mcr_cur = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
 	mcr_new = mcr_cur;
-	mcr_new |= MAC_MCR_MAX_RX_1536 | MAC_MCR_IPG_CFG | MAC_MCR_FORCE_MODE |
+	mcr_new |= MAC_MCR_IPG_CFG | MAC_MCR_FORCE_MODE |
 		   MAC_MCR_BACKOFF_EN | MAC_MCR_BACKPR_EN | MAC_MCR_FORCE_LINK;
 
 	/* Only update control register when needed! */
@@ -765,8 +765,8 @@ static void mtk_get_stats64(struct net_d
 static inline int mtk_max_frag_size(int mtu)
 {
 	/* make sure buf_size will be at least MTK_MAX_RX_LENGTH */
-	if (mtu + MTK_RX_ETH_HLEN < MTK_MAX_RX_LENGTH)
-		mtu = MTK_MAX_RX_LENGTH - MTK_RX_ETH_HLEN;
+	if (mtu + MTK_RX_ETH_HLEN < MTK_MAX_RX_LENGTH_2K)
+		mtu = MTK_MAX_RX_LENGTH_2K - MTK_RX_ETH_HLEN;
 
 	return SKB_DATA_ALIGN(MTK_RX_HLEN + mtu) +
 		SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
@@ -777,7 +777,7 @@ static inline int mtk_max_buf_size(int f
 	int buf_size = frag_size - NET_SKB_PAD - NET_IP_ALIGN -
 		       SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 
-	WARN_ON(buf_size < MTK_MAX_RX_LENGTH);
+	WARN_ON(buf_size < MTK_MAX_RX_LENGTH_2K);
 
 	return buf_size;
 }
@@ -2586,6 +2586,35 @@ static void mtk_uninit(struct net_device
 	mtk_rx_irq_disable(eth, ~0);
 }
 
+static int mtk_change_mtu(struct net_device *dev, int new_mtu)
+{
+       int length = new_mtu + MTK_RX_ETH_HLEN;
+       struct mtk_mac *mac = netdev_priv(dev);
+       struct mtk_eth *eth = mac->hw;
+       u32 mcr_cur, mcr_new;
+
+       if (!MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628)) {
+               mcr_cur = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
+               mcr_new = mcr_cur & ~MAC_MCR_MAX_RX_MASK;
+
+               if (length <= 1518)
+                       mcr_new |= MAC_MCR_MAX_RX(MAC_MCR_MAX_RX_1518);
+               else if (length <= 1536)
+                       mcr_new |= MAC_MCR_MAX_RX(MAC_MCR_MAX_RX_1536);
+               else if (length <= 1552)
+                       mcr_new |= MAC_MCR_MAX_RX(MAC_MCR_MAX_RX_1552);
+               else
+                       mcr_new |= MAC_MCR_MAX_RX(MAC_MCR_MAX_RX_2048);
+
+               if (mcr_new != mcr_cur)
+                       mtk_w32(mac->hw, mcr_new, MTK_MAC_MCR(mac->id));
+       }
+
+       dev->mtu = new_mtu;
+
+       return 0;
+}
+
 static int mtk_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
 	struct mtk_mac *mac = netdev_priv(dev);
@@ -2882,6 +2911,7 @@ static const struct net_device_ops mtk_n
 	.ndo_set_mac_address	= mtk_set_mac_address,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_do_ioctl		= mtk_do_ioctl,
+	.ndo_change_mtu         = mtk_change_mtu,
 	.ndo_tx_timeout		= mtk_tx_timeout,
 	.ndo_get_stats64        = mtk_get_stats64,
 	.ndo_fix_features	= mtk_fix_features,
@@ -2985,7 +3015,10 @@ static int mtk_add_mac(struct mtk_eth *e
 	eth->netdev[id]->irq = eth->irq[0];
 	eth->netdev[id]->dev.of_node = np;
 
-	eth->netdev[id]->max_mtu = MTK_MAX_RX_LENGTH - MTK_RX_ETH_HLEN;
+        if (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628))
+		eth->netdev[id]->max_mtu = MTK_MAX_RX_LENGTH - MTK_RX_ETH_HLEN;
+        else
+		eth->netdev[id]->max_mtu = MTK_MAX_RX_LENGTH_2K - MTK_RX_ETH_HLEN;
 
 	if (name)
 		strlcpy(eth->netdev[id]->name, name, IFNAMSIZ);
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -20,12 +20,13 @@
 #include "mtk_ppe.h"
 
 #define MTK_QDMA_PAGE_SIZE	2048
-#define	MTK_MAX_RX_LENGTH	1536
+#define MTK_MAX_RX_LENGTH	1536
+#define MTK_MAX_RX_LENGTH_2K	2048
 #define MTK_TX_DMA_BUF_LEN	0x3fff
 #define MTK_DMA_SIZE		512
 #define MTK_NAPI_WEIGHT		64
 #define MTK_MAC_COUNT		2
-#define MTK_RX_ETH_HLEN		(VLAN_ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN)
+#define MTK_RX_ETH_HLEN		(ETH_HLEN + ETH_FCS_LEN)
 #define MTK_RX_HLEN		(NET_SKB_PAD + MTK_RX_ETH_HLEN + NET_IP_ALIGN)
 #define MTK_DMA_DUMMY_DESC	0xffffffff
 #define MTK_DEFAULT_MSG_ENABLE	(NETIF_MSG_DRV | \
@@ -352,7 +353,12 @@
 
 /* Mac control registers */
 #define MTK_MAC_MCR(x)		(0x10100 + (x * 0x100))
-#define MAC_MCR_MAX_RX_1536	BIT(24)
+#define MAC_MCR_MAX_RX_MASK	GENMASK(25, 24)
+#define MAC_MCR_MAX_RX(_x)	(MAC_MCR_MAX_RX_MASK & ((_x) << 24))
+#define MAC_MCR_MAX_RX_1518	0x0
+#define MAC_MCR_MAX_RX_1536	0x1
+#define MAC_MCR_MAX_RX_1552	0x2
+#define MAC_MCR_MAX_RX_2048	0x3
 #define MAC_MCR_IPG_CFG		(BIT(18) | BIT(16))
 #define MAC_MCR_FORCE_MODE	BIT(15)
 #define MAC_MCR_TX_EN		BIT(14)
